@page "/instrument/{Figi}"
@using System.Drawing
@using ChartJs.Blazor.ChartJS.Common
@using ChartJs.Blazor.ChartJS.Common.Axes
@using ChartJs.Blazor.ChartJS.Common.Axes.Ticks
@using ChartJs.Blazor.ChartJS.Common.Enums
@using ChartJs.Blazor.ChartJS.Common.Properties
@using ChartJs.Blazor.ChartJS.Common.Time
@using ChartJs.Blazor.ChartJS.LineChart
@using ChartJs.Blazor.Charts
@using ChartJs.Blazor.Util
@using GUI.Scripts
@inject NavigationManager NavigationManager
@inject ISessionStorageService Storage

<ChartJsLineChart @ref="lineChartJs" Config="@lineConfig" Width="600" Height="300"/>

@code {

    [Parameter]
    public string Figi { get; set; }

    private string name = "";
    private string token = "";
    private ChartJsLineChart lineChartJs;
    private LineConfig lineConfig;
    private LineDataset<TimeTuple<decimal>> tempDataSet;
    private DateTime lastTime;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            token = await Storage.GetItemAsync<string>("tinkoffToken");

            if (token == null)
            {
                lineConfig.Options.Title.Text = new IndexableOption<string>("Access error");

                await lineChartJs.Update();

                return;
            }

            IEnumerable<Candle> list = null;

            try
            {
                list = await HubConnector.SubscribeOnCandle(OnReceivedMessage, BrokerType.TinkoffBroker, Figi, token);

                if (list.Any())
                {
                    AddCandles(list);

                    await UpdateNameInstrument();
                }
                else
                {
                    ChangeTitle("Exchange doesn't work");
                }
            }
            catch (InternalServerException e)
            {
                ChangeTitle("Figi not found");
            }
        }
    }

    private async Task UpdateNameInstrument()
    {
        name = await Storage.GetItemAsync<string>("tinkoffInstrumentName");

        ChangeTitle(name);
    }

    private async void ChangeTitle(string title)
    {
        lineConfig.Options.Title.Text = new IndexableOption<string>(title);
        await lineChartJs.Update();
    }

    private void OnReceivedMessage(Candle Candle)
    {
        if (lastTime == null || lastTime != Candle.Time)
        {
            lastTime = Candle.Time;

            tempDataSet.Add(new TimeTuple<decimal>(new Moment(Candle.Time), Candle.Close));
            if (tempDataSet.Data.Count > 15)
            {
                tempDataSet.RemoveAt(0);
            }
            lineConfig.Data.Datasets.Add(tempDataSet);

            lineChartJs.Update();
        }
    }

    private void AddCandles(IEnumerable<Candle> candles)
    {
        tempDataSet.AddRange(candles.ToList().ConvertAll(candle =>
            new TimeTuple<decimal>(new Moment(candle.Time), candle.Close)));
    }

    private void OnError()
    {
        lineConfig.Options.Title.Text = "Instrument not found";

        lineChartJs.Update();
    }

    protected override void OnInitialized()
    {
        SetChartConfig();
    }

    private void SetChartConfig()
    {
        lineConfig = new LineConfig
        {
            Options = new LineOptions
            {
                Responsive = true,
                Title = new OptionsTitle
                {
                    Display = true,
                    Text = name
                },
                Tooltips = new Tooltips
                {
                    Mode = InteractionMode.Nearest,
                    Intersect = false
                },
                Scales = new Scales
                {
                    xAxes = new List<CartesianAxis>
                    {
                        new TimeAxis
                        {
                            Distribution = TimeDistribution.Linear,
                            Ticks = new TimeTicks
                            {
                                Source = TickSource.Data
                            },
                            Time = new TimeOptions
                            {
                                Unit = TimeMeasurement.Minute,
                                Round = TimeMeasurement.Minute,
                                TooltipFormat = "DD.MM.YYYY HH:mm",
                                DisplayFormats = TimeDisplayFormats.DE_CH
                            }
                        }
                    }
                },
                Hover = new LineOptionsHover
                {
                    Intersect = true,
                    Mode = InteractionMode.Y
                },
                Legend =
                {
                    Display = false
                }
            }
        };

        tempDataSet = new LineDataset<TimeTuple<decimal>>
        {
            BorderColor = ColorUtil.FromDrawingColor(Color.CornflowerBlue),
            Fill = false,
            BorderWidth = 2,
            PointRadius = 3,
            PointBorderWidth = 1,
            SteppedLine = SteppedLine.False
        };
    }

}